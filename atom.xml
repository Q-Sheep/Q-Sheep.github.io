<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Q-Sheep妙妙屋</title>
  
  <subtitle>道路很拥挤，却是寂寞的，因为没人爱它。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-15T03:19:15.271Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Q-Sheep</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwn学习记录一</title>
    <link href="http://example.com/2024/03/31/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/"/>
    <id>http://example.com/2024/03/31/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</id>
    <published>2024-03-31T13:20:50.000Z</published>
    <updated>2024-04-15T03:19:15.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="寄存器总览"><a href="#寄存器总览" class="headerlink" title="寄存器总览"></a>寄存器总览</h2><p>总览不同寄存器的区别和作用</p><blockquote><pre><code>RIP：程序计数寄存器，来存放下一条即将用来执行的指令的地址，它决定程序执行的流程。（较常用）RBP：栈基寄存器，存放当前栈帧的栈底地址（较常用）RAX：通用寄存器。存放函数返回值RSP：栈顶寄存器，存放当前栈帧的栈顶地址（较常用）RAX：随机存取寄存器AX：累加寄存器，分为AH高八位和AL低八位AH：累加寄存器，AX（16位）寄存器的高八位AL：累加寄存器，AX（16位）寄存器的低八位EAX:累加寄存器，是很多加法乘法指令的缺省寄存器EBX：基地址寄存器，在内存寻址时存放基地址ECX：计数器EDX：数据寄存器，被用于来放整数除法产生的余数ESI：源变址寄存器EDI：目的变址寄存器EBP：扩展基址指针寄存器，EBP来存储当前函数状态的基地址，在函数运行时不变，可以用来索引|确定函数参数或局部变量 的位置。（较常用）ESP：栈指针寄存器，ESP用来存储函数调用栈的栈顶地址，在压栈和退栈时 发生变化。（较常用）EIP：指令指针寄存器，EIP用来存储即将执行的程序指令的地址, cpu依照EIP的存储内容读取指令并执行，EIP 随之指向相 邻的下一条指令,如此反复,程序就得以连续执行指令。（较常用）————————————————64位cpu对应RSP（栈顶寄存器）,RBP（栈基寄存器）,RIP（程序计数寄存器）三个寄存器。32位cpu则对应ESP（栈指针寄存器），EBP（扩展基址指针寄存器），EIP（指令指针寄存器）三个寄存器。R开头：64bit, 8字节（1字节=8bit）E开头：32bit, 4字节EAX（累加寄存器）是32位， AX 是EAX的低16位 ， AL 和AH是AX的低8位和高8位。AX,BX,CX：16bit, 2字节AH, AL: 8bit, 1字节————————————————BX是基（base）地址寄存器：四个寄存器中唯一可作为存储器指针使用的寄存器。CX寄存器是计数(count)寄存器：在字符串操作和循环操作时，用它来控制重复循环操作次数。在移位操作时，cl寄存器用来保存移位的位数。BP和SP寄存器称为指针寄存器：BP主要用于给出堆栈中数据区基址的偏移，从而方便地实现直接存取堆栈中的数据，所以BP也称为基指针寄存器，正常情况下SP只作为堆栈指针使用，即保存堆栈栈顶地址的偏移。</code></pre></blockquote><p>ax  16位    eax   32位     rax    64位<br>al表示ax寄存器的低八位</p><p>PTR   指针<br>BYTE   8位<br>WORD   16位<br>DWORD    32位<br>QWORD    64位</p><p>rbp和rsp用来去做栈  rax用来储存程序的返回值 </p><p><img src="https://s2.loli.net/2024/04/14/btjphJ2WOwnz671.png" alt="image-20240302102233231"></p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>一个栈桢保存一个函数的状态信息，复合函数每调用一个子函数就会在函数调用栈中新增一个栈帧</p><p>栈帧的栈底保存在ebp或rbp中，栈顶保存在esp或rsp中，cpu32位（x86)e开头，64位r开头</p><p><img src="https://s2.loli.net/2024/04/14/VH3vn2EkUC5GpRb.png" alt="image-20240328164640740"></p><p>右侧为计算机虚拟内存，中间stack部分就是栈</p><p>ebp和esp之间的部分就是当前函数栈帧，紧邻这一部分的高地址位就是复合函数栈帧</p><p>左侧arguments是子函数的，子函数的信息保存在父函数末尾</p><p><strong>stack frame pointer</strong></p><p>在当前调用子函数返回之后需要恢复上一个栈帧的信息，也就意味着ebp指针的位置也要被恢复，指针的值被保存在stack frame pointer中，他会在当前栈帧紧邻的上一个字长记录父函数的栈帧的栈底指针的值，方便之后恢复</p><p><strong>callee saved registers</strong></p><p>“被调用者保存寄存器”      在程序调用过程中，这些寄存器中的值需要被保存，不能被覆盖；当某个程序调用这些寄存器，被调用寄存器会先保存这些值然后再进行调用，且在调用结束后恢复被调用之前的值</p><p><strong>local variables</strong></p><p>当前函数栈帧的局部变量区（栈溢出发生在这里）</p><p> <strong>两个很重要的部分</strong></p><p> <em>return address</em>   返回地址 </p><p><em>stack frame pointer</em>   上一个栈帧的栈顶的值，也就是上一个栈帧ebp寄存器的值 </p><p>​                                （因为栈的存储特点（压栈）导致上一个函数的栈帧向上移动了一位）</p><h2 id="压栈"><a href="#压栈" class="headerlink" title="压栈"></a>压栈</h2><p>倒序压栈，子函数的末尾先被压入，且从栈顶开始压栈，也就是说调用函数的开头在栈顶，而末尾更靠近栈底</p><p><img src="https://s2.loli.net/2024/04/14/uB7whctxyvz4eUM.png" alt="image-20240328171701289"></p><p>且栈的特殊点在于低位是栈顶，高位是栈底（这一点在虚拟内存栈和堆对于空白区域的运用是有关的</p><p><img src="https://s2.loli.net/2024/04/14/5vTHSYPKAxoibwC.png" alt="image-20240328171830910"></p><ul><li><p>在压栈的过程中esp所对应的位置值会不断变小，这符合栈结构向下延伸的特点</p></li><li><p>压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态</p></li><li><p>在编译过程中就会确定栈的空间大小（栈一般约有8MB的空间，堆相对来说大很多，可以申请几GB的内存空间）</p></li><li><p>在压栈完成之后，ebp指向的是子函数的栈底，esp指向的是子函数的栈顶</p></li><li><p>对于栈来说他的栈顶永远是当前执行函数所对应的栈帧</p></li></ul><h2 id="子函数和父函数"><a href="#子函数和父函数" class="headerlink" title="子函数和父函数"></a>子函数和父函数</h2><p>首先是两个名词：调用函数  <strong>caller</strong>   被调用函数  <strong>callee</strong> </p><p><img src="https://s2.loli.net/2024/04/14/AkneDb3sjaE9IxB.png" alt="image-20240328172921688"></p><p>例如图片中的c文件脚本，运行的时候main函数会调用sum函数，因此在这个脚本中sum函数是子函数，main函数是sum函数的父函数</p><p>在main函数调用sum函数时会把sum函数压栈到main函数的栈帧，将sum1，2逆序压入栈帧之中</p><h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><p> 开启了的话就会在你的rbp上面放一个canary，就是一串随机数，<em>最后一个字节一定是00</em></p><p><strong>解决方法</strong></p><p>1.是printf，给他打印出来，打印的时候记得把他的最后一个字节填充了，不然截断了打印不出来，这个的话要学一下如何去接受，可能是个小难点</p><p>2.是格式化字符串漏洞，就是通过%p给他打印出来，记得找准位置哈，%n$p（n是个常数）给他精准打印出来</p><p>3.是爆破，这个使用可能比较局限，因为每次运行程序canary是会变的，所以在特定的情况下才能用</p><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>简单来讲就是每一次运行，函数的地址会不一样，ida里面的地址不能直接用，我们ida反编译的时候能看到地址，打开会发现地址变成了一个很小的数可能就四位数，也就是说，ida中显示的不再是一个准确的地址，是一个偏移地址，每次程序运行的时候，他都会把偏移地址，和一个随机的pie基址加一起，作为她的真实的地址，在做这种题的时候，我们就需要先去泄露出来一个函数的地址，再去找到他所对应的偏移，然后把他们减一下，找到偏移，就能够计算出来pie基址了，这下子所有的地址都能找到了</p><p>这个的话，只要搞清楚偏移地址和pie基址之间的关系，剩下的和pie没开没啥区别，就是把原来确定的地址搞的随机化了，</p><p>比如说一个地址本来是0x400111，你开了pie之后，他在ida里面变成了0x111，假如你把他泄露出来了，泄露出来的是0x300111，那你就可以把0x300111和0x111做个差，就计算出来了pie基址，也就是0x300000，剩下的，你只要把ida里面的地址加上一个pie基址就行了</p><h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>这个又叫做栈不可执行，就是<strong>放到栈里面的东西是不能够执行的</strong>，就比如说把systembinsh，写到了栈里面，但是是执行不了的</p><p>比如说本来能通过asm（shellcraft.sh（））去给他写一个获取权限的东西，让他执行就能获取权限了，开了NX保护之后可能就不能这样了，这样的话就用libc，或者通过mprotect改变bss段的权限写到bss那边再去执行也行</p><h1 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h1><h2 id="定义与常识"><a href="#定义与常识" class="headerlink" title="定义与常识"></a>定义与常识</h2><p>栈溢出在本质上属于缓冲区溢出</p><p><img src="https://s2.loli.net/2024/04/15/Ol9JIphrzk8D67S.png" alt="image-20240415105835952"></p><p>bss的溢出可利用性特别依赖于程序本身编写的逻辑，对于一些关键函数在bss中的话bss溢出便可以造成一些比较严重的后果，相比之下栈本身带有return address只要发生溢出就会对程序产生严重的攻击效果，而堆溢出也是比较依赖于关键函数通常要用间接方式来控制程序执行流</p><p><img src="https://s2.loli.net/2024/04/15/VPKm3zD5BlfYAba.png" alt="image-20240415110811684"></p><h2 id="C语言函数调用栈"><a href="#C语言函数调用栈" class="headerlink" title="C语言函数调用栈"></a>C语言函数调用栈</h2><p>函数调用栈在虚拟内存用户空间的最高地址</p><p><img src="https://s2.loli.net/2024/04/14/Doj2fmztnpHPa58.png" alt="image-20240414083149177"></p><p>父函数每调用一个子函数就会在函数调用栈中新增一个栈帧</p><p><img src="https://s2.loli.net/2024/04/14/uB7whctxyvz4eUM.png" alt="image-20240328171701289"></p><p>如上图，先压入调用函数的参数</p><p><img src="F:/%E4%BD%A0%E6%9C%89%E5%A4%9A%E6%83%B3pwn%E7%AC%94%E8%AE%B0/picture/image-20240328173558993.png" alt="image-20240328173558993"></p><p>然后会将函数的返回地址（return address）压入栈顶，在sum函数执行完之后会运行return 0自动返回</p><blockquote><p>这里压入的返回地址就是return 0的地址</p></blockquote><p><img src="https://s2.loli.net/2024/04/14/kV7cH6uPW4Qiynt.png" alt="image-20240328180615269"></p><p>在处理完sum函数之后就要恢复main函数的栈帧，这里就需要main函数的相关信息，也就意味着在处理sum函数之前我们就需要保存main函数的信息，这一步就是通过将main函数栈帧的ebp压入栈帧来实现的</p><p><img src="https://s2.loli.net/2024/04/14/9fLbFmh5CiY4kOD.png" alt="image-20240328182825190"></p><p>这里是将调用函数（callee) 的局部变量等数据压入栈内</p><blockquote><p>这一部分数据在调用完毕之后就会自动释放掉</p><p>但是释放掉只是移动指针使得目的区域不再被使用而不是抹除数据（这也是磁盘数据恢复的原理</p></blockquote><p><img src="https://s2.loli.net/2024/04/14/nH3UwFoESKlJVrD.png" alt="image-20240414205532333"></p><p>详细分析第一个汇编代码</p><p><img src="https://s2.loli.net/2024/04/14/SBVOaACtTJKZXo1.png" alt="image-20240414210256044"></p><p>如图是一个C语言代码对应的汇编代码</p><p>主要函数caller调用了被调用函数callee</p><p>一般来说遵循C语言函数调用规范的函数的第一条都是push  %ebp   这一条代码的作用是保存父函数栈底的状态</p><p>相对应的汇编代码末尾的leave函数是恢复父函数的栈底</p><p>ret(return)就是进入父函数下一条指令</p><p><img src="https://s2.loli.net/2024/04/15/bYCmpWqR7uh9MrF.png" alt="image-20240415101848496"></p><p>第二行mov %esp,%ebp就是移动esp到ebp位置，因为ebp已经到新的栈帧处了</p><p><img src="https://s2.loli.net/2024/04/15/XSbTzsBxgWvLFi9.png" alt="image-20240415101916589"></p><p>sub为新的局部变量开辟空间，是esp-0x10然后就开辟出了一个0x10大小的空间</p><p><img src="https://s2.loli.net/2024/04/15/zDG8FqKwmTbXl19.png" alt="image-20240415101938229"></p><p>接下来三个push就是逆序压入被调用函数需要的三个参数</p><p><img src="https://s2.loli.net/2024/04/15/wlDmAnuexNSWK9O.png" alt="image-20240415101957649"></p><p>call lf&lt;calller+0xd&gt;调用被调函数</p><blockquote><p>call和jump的辨析：jump是一个跳转指令，例如上图如果jump指令从1e到29那么就是把eip从1e移动到29，但是调用call之后不仅把eip移动到了指定位置，还自带保存了返回地址（return address），这里的返回地址是23也就是call函数下一行函数的地址</p></blockquote><p>到这里就进入了被调函数</p><p><img src="https://s2.loli.net/2024/04/15/yPBHz74JVFNYtDq.png" alt="image-20240415102658934"></p><p>第一行也是push先保存主要函数的栈帧，然后把esp的值赋给ebp从而把ebp抬高到esp所在位置</p><p><img src="https://s2.loli.net/2024/04/15/gzZCVA5Y4LxtqEd.png" alt="image-20240415102828086"></p><p>这部分的函数是在对传进来的三个参数（1，2，3）进行参数运算</p><p>最后运算结果保存在了eax寄存器中（约定俗成的将eax作为函数返回值的保存地址）</p><p><img src="https://s2.loli.net/2024/04/15/gBmA5xbuZ7kXM2h.png" alt="image-20240415103058659"></p><p>被调函数计算完成之后就要返回主要函数了</p><blockquote><p>pop与leave的辨析：leave比起pop多了一个把esp移到ebp位置的操作，leave %ebp &#x3D;mov %ebp,%esp  pop %ebp</p></blockquote><p>因为子函数没有开辟任何局部变量所以他在返回的时候ebp已经在esp相同的位置了</p><p><img src="https://s2.loli.net/2024/04/15/whWPfFXgr2E4HCN.png" alt="image-20240415103907117"></p><p>执行ret函数之后esp向上抬高了一位，eip回到了主调函数下一行函数</p><p><img src="https://s2.loli.net/2024/04/15/TagQIX4dpjLUPAR.png" alt="image-20240415104126730"></p><p>清空他的局部变量和被调参数</p><p><img src="https://s2.loli.net/2024/04/15/IZpC4jLtRagAOln.png" alt="image-20240415104142761"></p><p>同样计算相应数据之后保存在eax中，eax保存了caller函数的执行参数</p><p><img src="https://s2.loli.net/2024/04/15/sxGuNCRKDZObzl1.png" alt="image-20240415104559107"></p><p><img src="https://s2.loli.net/2024/04/15/6CGAExj9ZMObFcg.png" alt="image-20240415104716961"></p><p>此时ebp和esp的位置需要使用leave函数而不是pop</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最终目标就是获得目标服务器的shell从而操纵控制台来获取所需数据</p><p>所用方法就是控制程序的执行流</p><p>需要控制pc寄存器，在eip&#x2F;rip中写入数据</p><p>因而需要控制能给pc寄存器赋值的数据，对栈来说return address会在返回的时候写入数据</p><p>栈溢出就是通过一些特殊的方法在return address区域写入我们所需的能够挟持程序执行流的数据进而get shell</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;寄存器&quot;&gt;&lt;a href=&quot;#寄存器&quot; class=&quot;headerlink&quot; title=&quot;寄存器&quot;&gt;&lt;/a&gt;寄存器&lt;/h1&gt;&lt;h2 id=&quot;寄存器总览&quot;&gt;&lt;a href=&quot;#寄存器总览&quot; class=&quot;headerlink&quot; title=&quot;寄存器总览&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="PWN" scheme="http://example.com/tags/PWN/"/>
    
    <category term="栈溢出" scheme="http://example.com/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/01/06/hello-world/"/>
    <id>http://example.com/2024/01/06/hello-world/</id>
    <published>2024-01-06T07:11:01.534Z</published>
    <updated>2024-01-06T07:11:01.534Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
